<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">Nonogram World</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <script>
        // Prevent theme flick: Apply theme before body renders
        (function () {
            const theme = localStorage.getItem('nomo7-theme') || 'dark';
            if (theme === 'dark') document.documentElement.classList.add('dark');
            else document.documentElement.classList.remove('dark');
        })();
    </script>
    <style>
        .map-content {
            line-height: 1.8;
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }

        .map-placeholder {
            width: 100%;
            height: 600px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: var(--radius);
            margin: 20px 0;
            position: relative;
            overflow: hidden;
            /* Viewport */
            cursor: grab;
            user-select: none;
            border: 1px solid var(--border-color);
        }

        .map-placeholder:active {
            cursor: grabbing;
        }

        #hex-grid-container {
            position: absolute;
            transform-origin: 0 0;
            will-change: transform;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: white;
            color: #334155;
            border: 1px solid #cbd5e1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }

        .dark .zoom-btn {
            background: #1e293b;
            color: #e2e8f0;
            border-color: #334155;
        }

        .zoom-btn:hover {
            background: #f8fafc;
        }

        .dark .zoom-btn:hover {
            background: #334155;
        }

        .hex-svg {
            overflow: visible;
        }

        .hexagon {
            fill: transparent;
            stroke: none !important;
            /* Borders handled by grid-overlay */
            transition: fill 0.3s ease;
            cursor: pointer;
            pointer-events: all;
        }

        .hexagon:hover {
            fill: var(--hex-hover-color, #cbd5e1);
            outline: none;
        }

        /* Hover border effect */
        .hexagon-hover-stroke {
            fill: none;
            stroke: var(--hex-hover-stroke, var(--primary-color));
            stroke-width: calc(var(--hex-hover-stroke-width, 2px) / var(--map-zoom, 1));
            stroke-opacity: var(--hex-hover-stroke-opacity, 1);
            pointer-events: none;
            display: none;
        }

        .grid-lines {
            fill: none;
            stroke: var(--primary-color);
            stroke-width: calc(1px / var(--map-zoom, 1));
            pointer-events: none;
        }

        .dark .hexagon {
            fill: transparent;
        }

        .hexagon.colored {
            /* fill set inline in JS */
            fill-opacity: 0.6;
        }

        .dark .hexagon.colored {
            fill-opacity: 0.7;
        }
    </style>
    <script src="/js/layout.js"></script>
    <script src="/js/i18n.js"></script>
    <script src="/js/mapConfig.js"></script>
</head>

<body>
    <header></header>

    <main class="main-container">
        <section class="game-section map-content">
            <h1 style="color: var(--primary-color);" data-i18n="nav.map">Карта приключений</h1>

            <p style="margin-bottom: 20px;">Здесь вы сможете выбирать уровни и следить за своим прогрессом!</p>

            <div class="map-placeholder" id="viewport">
                <div id="hex-grid-container"></div>

                <div class="zoom-controls">
                    <span id="zoom-level-display"
                        style="font-size: 10px; color: var(--text-secondary); margin-bottom: 2px;">1.0x</span>
                    <button class="zoom-btn" onclick="adjustZoom(0.1)" title="Zoom In">+</button>
                    <button class="zoom-btn" onclick="adjustZoom(-0.1)" title="Zoom Out">-</button>
                    <button class="zoom-btn" onclick="resetView()" title="Reset View">⟲</button>
                </div>

                <div style="display:none; color: var(--text-secondary);" id="map-error">
                    Карта загружается или временно недоступна...
                </div>
            </div>

            <script>
                // Simple seed-based random generator (LCG)
                function seededRandom(seed) {
                    let m = 0x80000000;
                    let a = 1103515245;
                    let c = 12345;
                    let state = seed % m;
                    return function () {
                        state = (a * state + c) % m;
                        return state / (m - 1);
                    };
                }

                function stringToSeed(str) {
                    let seed = 0;
                    for (let i = 0; i < str.length; i++) {
                        seed = (seed << 5) - seed + str.charCodeAt(i);
                        seed |= 0;
                    }
                    return seed;
                }

                let isDragging = false;
                let startX, startY;
                let scrollLeft, scrollTop;
                let currentScale = 1.0;
                let offsetX = 0;
                let offsetY = 0;

                function initMapSettings() {
                    const config = window.mapConfig || {};
                    const root = document.documentElement;
                    if (config.hoverColorLight) root.style.setProperty('--hex-hover-color', config.hoverColorLight);
                    if (config.hoverColorDark) root.style.setProperty('--hex-hover-color-dark', config.hoverColorDark);
                    if (config.hoverStrokeColorLight) root.style.setProperty('--hex-hover-stroke', config.hoverStrokeColorLight);
                    if (config.hoverStrokeColorDark) root.style.setProperty('--hex-hover-stroke-dark', config.hoverStrokeColorDark);
                    if (config.hoverStrokeWidth) root.style.setProperty('--hex-hover-stroke-width', config.hoverStrokeWidth + 'px');
                    if (config.hoverStrokeOpacity !== undefined) root.style.setProperty('--hex-hover-stroke-opacity', config.hoverStrokeOpacity);

                    currentScale = config.zoom || 1.0;
                    updateGridTransform();
                }

                function generateHexGrid() {
                    const container = document.getElementById('hex-grid-container');
                    const config = window.mapConfig || { gridCols: 30, gridRows: 20, hexagonSize: 20 };

                    const size = config.hexagonSize;
                    const fillPadding = config.fillPadding || 0;
                    const cols = config.gridCols;
                    const rows = config.gridRows;
                    const seed = config.seed || 'default';
                    const rng = seededRandom(stringToSeed(seed));
                    const fillProb = config.fillPercentage !== undefined ? config.fillPercentage : 0.15;

                    const hexWidth = size * Math.sqrt(3);
                    const hexHeight = size * 2;
                    const vertDist = hexHeight * 3 / 4;
                    const horizDist = hexWidth;

                    const totalWidth = cols * horizDist + (horizDist / 2);
                    const totalHeight = rows * vertDist + (hexHeight / 4);

                    container.style.width = totalWidth + 'px';
                    container.style.height = totalHeight + 'px';

                    // Pre-calculate colored status and color for all hexes
                    const gridData = [];
                    const hexColors = config.hexColors || [config.primaryColor || '#6366f1'];
                    for (let r = 0; r < rows; r++) {
                        gridData[r] = [];
                        for (let c = 0; c < cols; c++) {
                            const isColored = rng() < fillProb;
                            const colorIndex = Math.floor(rng() * hexColors.length);
                            gridData[r][c] = {
                                isColored: isColored,
                                color: hexColors[colorIndex]
                            };
                        }
                    }

                    let fillGroup = "";
                    let gridPathD = "";
                    const processedEdges = new Set();

                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            let x = c * horizDist + (horizDist / 2);
                            if (r % 2 !== 0) x += horizDist / 2;
                            const y = r * vertDist + (hexHeight / 2);
                            const hexInfo = gridData[r][c];
                            const isColored = hexInfo.isColored;

                            // Hexagon Points
                            const fullPoints = [];
                            const fillPoints = [];
                            for (let i = 0; i < 6; i++) {
                                const angle_deg = 60 * i - 30;
                                const angle_rad = Math.PI / 180 * angle_deg;

                                // Full size for grid
                                const fx = x + size * Math.cos(angle_rad);
                                const fy = y + size * Math.sin(angle_rad);
                                fullPoints.push({ x: fx, y: fy });

                                // Shrunk size for fill
                                const fillSize = Math.max(0, size - fillPadding);
                                const sx = x + fillSize * Math.cos(angle_rad);
                                const sy = y + fillSize * Math.sin(angle_rad);
                                fillPoints.push({ x: sx, y: sy });
                            }

                            // Fills Layer
                            const fillPointsStr = fillPoints.map(p => `${p.x},${p.y}`).join(' ');
                            const fullPointsStr = fullPoints.map(p => `${p.x},${p.y}`).join(' ');
                            const fillColor = isColored ? hexInfo.color : 'transparent';
                            fillGroup += `<polygon points="${fillPointsStr}" data-full-points="${fullPointsStr}" class="hexagon ${isColored ? 'colored' : ''}" style="fill: ${fillColor}" data-row="${r}" data-col="${c}" />`;

                            // Grid Lines Layer (Shared Unique Edges using FULL points)
                            for (let i = 0; i < 6; i++) {
                                const p1 = fullPoints[i];
                                const p2 = fullPoints[(i + 1) % 6];

                                // Neighbor coordinate logic (Pointy topped, starting from Top-Right 30deg)
                                // Edge indices matching points[i] to points[i+1]:
                                // 0: Right, 1: Bottom-Right, 2: Bottom-Left, 3: Left, 4: Top-Left, 5: Top-Right
                                let nr, nc;
                                if (r % 2 === 0) {
                                    // Even row hexes are shifted left
                                    const neighbors = [
                                        [r, c + 1],     // 0: Right
                                        [r + 1, c],     // 1: Bottom-Right
                                        [r + 1, c - 1], // 2: Bottom-Left
                                        [r, c - 1],     // 3: Left
                                        [r - 1, c - 1], // 4: Top-Left
                                        [r - 1, c]      // 5: Top-Right
                                    ];
                                    [nr, nc] = neighbors[i];
                                } else {
                                    // Odd row hexes are shifted right
                                    const neighbors = [
                                        [r, c + 1],     // 0: Right
                                        [r + 1, c + 1], // 1: Bottom-Right
                                        [r + 1, c],     // 2: Bottom-Left
                                        [r, c - 1],     // 3: Left
                                        [r - 1, c],      // 4: Top-Left
                                        [r - 1, c + 1]  // 5: Top-Right
                                    ];
                                    [nr, nc] = neighbors[i];
                                }

                                const neighborExists = nr >= 0 && nr < rows && nc >= 0 && nc < cols;
                                const neighborIsColored = neighborExists ? gridData[nr][nc].isColored : false;

                                // DRAW BORDER IF: 
                                // 1. Config.showEmptyBorders is true
                                // 2. One of the hexes is colored
                                if (config.showEmptyBorders || isColored || neighborIsColored) {
                                    const p1k = `${Math.round(p1.x * 100)},${Math.round(p1.y * 100)}`;
                                    const p2k = `${Math.round(p2.x * 100)},${Math.round(p2.y * 100)}`;
                                    const edgeKey = [p1k, p2k].sort().join('-');

                                    if (!processedEdges.has(edgeKey)) {
                                        processedEdges.add(edgeKey);
                                        gridPathD += `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y} `;
                                    }
                                }
                            }
                        }
                    }

                    container.innerHTML = `
                        <svg id="main-map-svg" width="${totalWidth}" height="${totalHeight}" class="hex-svg">
                            <g id="fills-layer">${fillGroup}</g>
                            <path d="${gridPathD}" class="grid-lines" id="grid-lines" />
                            <polygon id="hover-highlight" points="" class="hexagon-hover-stroke" />
                        </svg>
                    `;

                    // Hover interactions
                    const svg = document.getElementById('main-map-svg');
                    const highlight = document.getElementById('hover-highlight');

                    svg.addEventListener('mouseover', (e) => {
                        if (e.target.classList.contains('hexagon')) {
                            const points = e.target.getAttribute('data-full-points');
                            highlight.setAttribute('points', points);
                            highlight.style.display = 'block';
                        }
                    });

                    svg.addEventListener('mouseout', (e) => {
                        if (e.target.classList.contains('hexagon')) {
                            highlight.style.display = 'none';
                        }
                    });
                }

                function applyConstraints() {
                    const container = document.getElementById('hex-grid-container');
                    const viewport = document.getElementById('viewport');
                    const config = window.mapConfig || { hexagonSize: 20 };
                    const buffer = config.hexagonSize * currentScale;

                    const zoomedWidth = container.clientWidth * currentScale;
                    const zoomedHeight = container.clientHeight * currentScale;

                    // X constraints: Center if smaller, otherwise keep within bounds with buffer
                    if (zoomedWidth <= viewport.clientWidth) {
                        offsetX = (viewport.clientWidth - zoomedWidth) / 2;
                    } else {
                        offsetX = Math.max(viewport.clientWidth - zoomedWidth - buffer, Math.min(buffer, offsetX));
                    }

                    // Y constraints: Center if smaller, otherwise keep within bounds with buffer
                    if (zoomedHeight <= viewport.clientHeight) {
                        offsetY = (viewport.clientHeight - zoomedHeight) / 2;
                    } else {
                        offsetY = Math.max(viewport.clientHeight - zoomedHeight - buffer, Math.min(buffer, offsetY));
                    }
                }

                function updateGridTransform() {
                    applyConstraints();
                    const container = document.getElementById('hex-grid-container');
                    const root = document.documentElement;
                    root.style.setProperty('--map-zoom', currentScale);

                    const zoomDisplay = document.getElementById('zoom-level-display');
                    if (zoomDisplay) zoomDisplay.innerText = currentScale.toFixed(1) + 'x';

                    container.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${currentScale})`;

                    // Sync line widths with zoom
                    const lines = document.getElementById('grid-lines');
                    if (lines) lines.style.strokeWidth = (1 / currentScale) + 'px';

                    const highlight = document.getElementById('hover-highlight');
                    if (highlight) {
                        const config = window.mapConfig || {};
                        const sw = config.hoverStrokeWidth || 2;
                        highlight.style.strokeWidth = (sw / currentScale) + 'px';
                    }
                }

                function adjustZoom(delta) {
                    const config = window.mapConfig || {};
                    const minZoom = config.minZoom || 0.5;
                    const maxZoom = config.maxZoom || 3.0;

                    const newScale = Math.max(minZoom, Math.min(maxZoom, currentScale + delta));
                    if (newScale !== currentScale) {
                        currentScale = newScale;
                        updateGridTransform();
                    }
                }

                function resetView() {
                    const container = document.getElementById('hex-grid-container');
                    const viewport = document.getElementById('viewport');

                    currentScale = (window.mapConfig && window.mapConfig.zoom) || 1.0;

                    // Center the grid in the viewport initially
                    offsetX = (viewport.clientWidth - container.clientWidth * currentScale) / 2;
                    offsetY = (viewport.clientHeight - container.clientHeight * currentScale) / 2;

                    updateGridTransform();
                }

                // Interactive Panning
                const viewport = document.getElementById('viewport');

                viewport.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    viewport.style.cursor = 'grabbing';
                    startX = e.pageX - offsetX;
                    startY = e.pageY - offsetY;
                });

                window.addEventListener('mouseup', () => {
                    isDragging = false;
                    viewport.style.cursor = 'grab';
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    offsetX = e.pageX - startX;
                    offsetY = e.pageY - startY;
                    updateGridTransform();
                });

                // Zoom with wheel
                viewport.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;
                    adjustZoom(delta);
                }, { passive: false });

                window.addEventListener('DOMContentLoaded', () => {
                    initMapSettings();
                    generateHexGrid();
                    resetView(); // Center initially
                });
            </script>

            <div style="margin-top: 40px;">
                <a href="/index.html" class="btn" data-i18n="nav.play">Начать играть</a>
            </div>
        </section>
    </main>

    <footer></footer>
</body>

</html>